/**
 * Main Layout Component
 * CSS Grid-based 3-column layout: Sidebar + Primary + Secondary
 */

import { AuthComponent } from '../auth/AuthComponent';
import { SystemLogger } from '../system/SystemLogger';
import { UserStatus } from '../ui/UserStatus';
import { CacheManager } from '../../services/CacheManager';
import { AppState } from '../../services/AppState';
import { Router } from '../../services/Router';
import { PostNoteModal } from '../post/PostNoteModal';
import { AuthStateManager } from '../../services/AuthStateManager';
import { AuthService } from '../../services/AuthService';
import { NotificationsOrchestrator } from '../../services/orchestration/NotificationsOrchestrator';
import { NotificationsCacheService } from '../../services/NotificationsCacheService';
import { EventBus } from '../../services/EventBus';
import { BookmarkOrchestrator, type BookmarkWithMetadata } from '../../services/orchestration/BookmarkOrchestrator';
import type { Event as NostrEvent } from 'nostr-tools';
import { encodeNevent } from '../../services/NostrToolsAdapter';
import { UserProfileService } from '../../services/UserProfileService';
import { NostrTransport } from '../../services/transport/NostrTransport';
import { RelayConfig } from '../../services/RelayConfig';
import { ToastService } from '../../services/ToastService';
import { WalletBalanceDisplay } from '../ui/WalletBalanceDisplay';
import { URLNavigationModal } from '../navigation/URLNavigationModal';
import { KeyboardShortcutManager } from '../../services/KeyboardShortcutManager';
import { GlobalSearchView } from '../search/GlobalSearchView';

export class MainLayout {
  private element: HTMLElement;
  private systemLogger: SystemLogger;
  private userStatus: UserStatus | null = null;
  private urlNavigationModal: URLNavigationModal | null = null;
  private keyboardShortcutManager: KeyboardShortcutManager;
  private authComponent: any = null; // Store reference to trigger logout
  private cacheManager: CacheManager;
  private appState: AppState;
  private authStateManager: AuthStateManager;
  private authService: AuthService;
  private notificationsOrch: NotificationsOrchestrator;
  private notificationsCacheService: NotificationsCacheService;
  private eventBus: EventBus;
  private cacheSizeUpdateInterval: number | null = null;
  private authStateUnsubscribe: (() => void) | null = null;
  private badgeUpdateSubscriptionId: string | null = null;
  private walletBalanceDisplay: WalletBalanceDisplay | null = null;
  private globalSearchView: GlobalSearchView | null = null;

  constructor() {
    this.element = this.createElement();
    this.systemLogger = SystemLogger.getInstance();
    this.cacheManager = CacheManager.getInstance();
    this.appState = AppState.getInstance();
    this.authStateManager = AuthStateManager.getInstance();
    this.authService = AuthService.getInstance();
    this.notificationsOrch = NotificationsOrchestrator.getInstance();
    this.notificationsCacheService = NotificationsCacheService.getInstance();
    this.eventBus = EventBus.getInstance();
    this.setupNavigationLinks();
    this.setupScrollListener();
    this.setupTabSwitching();
    this.setupMentionLinks();
    this.initializeContent();
    this.startCacheSizeUpdates();
    this.setupAuthStateListener();
    this.setupNotificationsBadge();
    this.setupBookmarkUpdateListener();
    this.initializeWalletBalance();
    this.setupKeyboardShortcuts();
    this.initializeGlobalSearchView();
  }

  /**
   * Setup keyboard shortcuts
   */
  private setupKeyboardShortcuts(): void {
    console.log('[MainLayout] Setting up keyboard shortcuts');
    this.keyboardShortcutManager = KeyboardShortcutManager.getInstance();
    this.keyboardShortcutManager.registerSearchModalCallback(() => {
      console.log('[MainLayout] Search modal callback triggered');
      this.openSearchModal();
    });
    console.log('[MainLayout] Keyboard shortcuts setup complete');
  }

  /**
   * Initialize wallet balance display
   */
  private initializeWalletBalance(): void {
    const walletBalanceContainer = this.element.querySelector('.wallet-balance-container');
    if (walletBalanceContainer) {
      this.walletBalanceDisplay = new WalletBalanceDisplay();
      walletBalanceContainer.appendChild(this.walletBalanceDisplay.getElement());
    }
  }

  /**
   * Initialize search modal
   */
  private initializeSearchModal(): void {
    this.urlNavigationModal = new URLNavigationModal();
  }

  /**
   * Initialize global search view
   */
  private initializeGlobalSearchView(): void {
    this.globalSearchView = new GlobalSearchView();

    // Mount in secondary content
    const secondaryContent = this.element.querySelector('.secondary-content-body');
    if (secondaryContent) {
      secondaryContent.appendChild(this.globalSearchView.getElement());
    }
  }

  /**
   * Open search modal
   */
  private openSearchModal(): void {
    if (!this.urlNavigationModal) {
      this.initializeSearchModal();
    }
    this.urlNavigationModal?.open();
  }

  /**
   * Setup bookmark update listener to refresh bookmarks tab
   */
  private setupBookmarkUpdateListener(): void {
    this.eventBus.on('bookmark:updated', () => {
      // Re-render bookmarks tab if it's currently active
      const bookmarksTab = this.element.querySelector('[data-tab-content="bookmarks"]');
      if (bookmarksTab && bookmarksTab.classList.contains('secondary-tab-content--active')) {
        this.renderBookmarksTab(bookmarksTab as HTMLElement).catch(err => {
          console.error('Failed to refresh bookmarks:', err);
        });
      }
    });

    // Clear bookmarks on logout and switch to System Logs tab
    this.eventBus.on('user:logout', () => {
      const bookmarksTab = this.element.querySelector('[data-tab-content="bookmarks"]');
      if (bookmarksTab) {
        this.renderBookmarksTab(bookmarksTab as HTMLElement).catch(err => {
          console.error('Failed to clear bookmarks:', err);
        });
      }
      // Switch to System Logs tab
      this.switchToSystemLogsTab();
    });

    // Reload bookmarks on login and switch to System Logs tab
    this.eventBus.on('user:login', () => {
      // Switch to System Logs tab (bookmark list will reload on next tab click)
      this.switchToSystemLogsTab();
    });
  }

  /**
   * Switch to System Logs tab (e.g., after login/logout)
   */
  private switchToSystemLogsTab(): void {
    // Remove active class from all tabs
    this.element.querySelectorAll('.secondary-tab').forEach(t => t.classList.remove('secondary-tab--active'));
    this.element.querySelectorAll('.secondary-tab-content').forEach(c => c.classList.remove('secondary-tab-content--active'));

    // Activate System Logs tab
    const systemLogsTabButton = this.element.querySelector('[data-tab="system-log"]');
    const systemLogsTabContent = this.element.querySelector('[data-tab-content="system-log"]');

    if (systemLogsTabButton) {
      systemLogsTabButton.classList.add('secondary-tab--active');
    }
    if (systemLogsTabContent) {
      systemLogsTabContent.classList.add('secondary-tab-content--active');
    }
  }

  /**
   * Setup auth state listener to sync user status with login/logout
   */
  private setupAuthStateListener(): void {
    this.authStateUnsubscribe = this.authStateManager.subscribe((isLoggedIn) => {
      if (isLoggedIn) {
        // User logged in - set user status if we have current user
        const currentUser = this.authService.getCurrentUser();
        if (currentUser) {
          this.setUserStatus(currentUser.npub, currentUser.pubkey);
        }
      } else {
        // User logged out - clear user status
        this.clearUserStatus();
      }
    });
  }

  /**
   * Setup mention links (profile links in note content) to use router
   * Uses event delegation to catch all clicks on <a href="/profile/..."> and other internal links
   */
  private setupMentionLinks(): void {
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;

      // Check if clicked element or its parent is an internal link
      const link = target.closest('a[href^="/profile/"], a[href^="/mute-list"]') as HTMLAnchorElement;
      if (!link) return;

      e.preventDefault();
      const href = link.getAttribute('href');
      if (href) {
        Router.getInstance().navigate(href);
      }
    });
  }

  /**
   * Setup navigation links to use router instead of page reload
   */
  private setupNavigationLinks(): void {
    const homeLink = this.element.querySelector('.sidebar .home-link');
    if (homeLink) {
      homeLink.addEventListener('click', (e) => {
        e.preventDefault();
        this.handleHomeClick();
      });
    }

    const scrollToTopBtn = this.element.querySelector('.scroll-to-top-btn');
    if (scrollToTopBtn) {
      scrollToTopBtn.addEventListener('click', () => {
        this.scrollToTop();
      });
    }

    const notificationsLink = this.element.querySelector('.sidebar .notifications-link');
    if (notificationsLink) {
      notificationsLink.addEventListener('click', (e) => {
        e.preventDefault();
        const router = Router.getInstance();
        router.navigate('/notifications');
      });
    }

    const messagesLink = this.element.querySelector('.sidebar a[href="/messages"]');
    if (messagesLink) {
      messagesLink.addEventListener('click', (e) => {
        e.preventDefault();
        const router = Router.getInstance();
        router.navigate('/messages');
      });
    }

    const settingsLink = this.element.querySelector('.sidebar a[href="/settings"]');
    if (settingsLink) {
      settingsLink.addEventListener('click', (e) => {
        e.preventDefault();
        const router = Router.getInstance();
        router.navigate('/settings');
      });
    }

    const profileLink = this.element.querySelector('.sidebar .profile-link');
    if (profileLink) {
      profileLink.addEventListener('click', (e) => {
        e.preventDefault();
        const currentUser = this.authService.getCurrentUser();
        if (currentUser) {
          const router = Router.getInstance();
          router.navigate(`/profile/${currentUser.npub}`);
        }
      });
    }

    const searchLink = this.element.querySelector('.sidebar .search-link');
    if (searchLink) {
      searchLink.addEventListener('click', (e) => {
        e.preventDefault();
        this.openSearchModal();
      });
    }

    const clearCacheLink = this.element.querySelector('.sidebar .clear-cache-link');
    if (clearCacheLink) {
      clearCacheLink.addEventListener('click', (e) => {
        e.preventDefault();
        this.handleClearCache();
      });
    }

    const newPostBtn = this.element.querySelector('.sidebar .btn--new-post');
    if (newPostBtn) {
      newPostBtn.addEventListener('click', () => {
        this.handleNewPost();
      });
    }
  }

  /**
   * Handle home link click - scroll to top if in timeline, otherwise navigate
   */
  private handleHomeClick(): void {
    const router = Router.getInstance();
    const currentPath = router.getCurrentPath();

    // Check if already on timeline (home page)
    if (currentPath === '/' || currentPath === '/timeline') {
      // Already in timeline - scroll to top
      this.scrollToTop();
    } else {
      // Navigate to timeline
      router.navigate('/');
    }
  }

  /**
   * Scroll timeline to top
   */
  private scrollToTop(): void {
    const primaryContent = this.element.querySelector('.primary-content');
    if (primaryContent) {
      primaryContent.scrollTo({ top: 0, behavior: 'smooth' });
      // Reset scroll position in CSM
      this.appState.setState('timeline', { scrollPosition: 0 });
    }
  }

  /**
   * Setup scroll listener for scroll-to-top button visibility
   */
  private setupScrollListener(): void {
    // Wait for element to be mounted
    setTimeout(() => {
      const primaryContent = this.element.querySelector('.primary-content');
      const scrollToTopBtn = this.element.querySelector('.scroll-to-top-btn') as HTMLElement;

      if (primaryContent && scrollToTopBtn) {
        primaryContent.addEventListener('scroll', () => {
          const currentView = this.appState.getState('view').currentView;
          const scrollPosition = primaryContent.scrollTop;

          // Show button if in timeline and scrolled down (> 100px)
          if (currentView === 'timeline' && scrollPosition > 100) {
            scrollToTopBtn.style.display = 'inline-block';
          } else {
            scrollToTopBtn.style.display = 'none';
          }
        });
      }
    }, 100);
  }

  /**
   * Setup tab switching in aside.secondary-content
   */
  private setupTabSwitching(): void {
    const tabs = this.element.querySelectorAll('.secondary-tab');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = (tab as HTMLElement).dataset.tab;
        console.log('[TAB CLICK]', tabName);
        if (!tabName) return;

        // Remove active class from all tabs and contents
        this.element.querySelectorAll('.secondary-tab').forEach(t => t.classList.remove('secondary-tab--active'));
        this.element.querySelectorAll('.secondary-tab-content').forEach(c => c.classList.remove('secondary-tab-content--active'));

        // Add active class to clicked tab and corresponding content
        tab.classList.add('secondary-tab--active');
        const content = this.element.querySelector(`[data-tab-content="${tabName}"]`);
        console.log('[TAB CONTENT]', content);
        if (content) {
          content.classList.add('secondary-tab-content--active');

          // Re-render bookmarks tab when switching to it (to get fresh auth state)
          if (tabName === 'bookmarks') {
            console.log('[RENDERING BOOKMARKS]');
            this.renderBookmarksTab(content as HTMLElement).catch(err => {
              console.error('Failed to render bookmarks tab:', err);
            });
          }
        }
      });
    });
  }

  /**
   * Render bookmarks tab content
   */
  private async renderBookmarksTab(container: HTMLElement): Promise<void> {
    try {
      const authService = AuthService.getInstance();
      const currentUser = authService.getCurrentUser();

      console.log('[BookmarksTab] Current user:', currentUser ? currentUser.npub : 'null');

      if (!currentUser) {
        container.innerHTML = `
          <div class="bookmarks-empty-state">
            <p>Log in to see your bookmarks</p>
          </div>
        `;
        return;
      }

      // Show loading state with debug button
      container.innerHTML = `
        <div class="bookmarks-loading">
          Loading bookmarks...
          <button class="btn btn--passive" id="debug-bookmarks-btn" style="margin-top: 1rem;">
            üîç Debug Bookmark Events
          </button>
        </div>
      `;

      // Add debug button handler
      const debugBtn = container.querySelector('#debug-bookmarks-btn');
      debugBtn?.addEventListener('click', async () => {
        const bookmarkOrch = BookmarkOrchestrator.getInstance();
        await bookmarkOrch.debugFetchAllBookmarkEvents(currentUser.pubkey);
      });

      // Fetch bookmarks with metadata
      console.log('[BookmarksTab] Fetching bookmarks for:', currentUser.pubkey);
      const bookmarkOrch = BookmarkOrchestrator.getInstance();
      const bookmarksWithMeta = await bookmarkOrch.getAllBookmarksWithMetadata(currentUser.pubkey);
      console.log('[BookmarksTab] Got bookmarks with metadata:', bookmarksWithMeta);

      if (bookmarksWithMeta.length === 0) {
        container.innerHTML = `
          <div class="bookmarks-empty-state">
            <p>No bookmarks collected yet</p>
          </div>
        `;
        return;
      }

      // Fetch events from relays
      const transport = NostrTransport.getInstance();
      const relayConfig = RelayConfig.getInstance();
      const relays = relayConfig.getAllRelays().map(r => r.url);

      const bookmarkEvents = await transport.fetch(relays, [{
        ids: bookmarksWithMeta.map(b => b.id)
      }], 5000);

      console.log('[BookmarksTab] Fetched', bookmarkEvents.length, 'events from relays');

      if (bookmarkEvents.length === 0) {
        container.innerHTML = `
          <div class="bookmarks-empty-state">
            <p>Could not load bookmarked notes</p>
          </div>
        `;
        return;
      }

      // Render bookmark list with debug button
      container.innerHTML = `
        <button class="btn btn--passive" id="debug-bookmarks-btn" style="margin-bottom: 1rem;">
          üîç Debug Bookmark Events
        </button>
        <div class="bookmarks-list"></div>
      `;

      // Add debug button handler
      const debugBtn2 = container.querySelector('#debug-bookmarks-btn');
      debugBtn2?.addEventListener('click', async () => {
        const bookmarkOrch = BookmarkOrchestrator.getInstance();
        await bookmarkOrch.debugFetchAllBookmarkEvents(currentUser.pubkey);
      });

      const list = container.querySelector('.bookmarks-list');
      if (!list) return;

      const userProfileService = UserProfileService.getInstance();

      // Sort by created_at DESC (newest first)
      bookmarkEvents.sort((a, b) => b.created_at - a.created_at);

      for (const event of bookmarkEvents) {
      // Find metadata for this event
      const metadata = bookmarksWithMeta.find(b => b.id === event.id);
      const isPrivate = metadata?.isPrivate || false;

      const profile = await userProfileService.getUserProfile(event.pubkey);
      const username = profile?.name || 'Anonymous';
      const snippet = this.getTextSnippet(event.content, 100);
      const timeAgo = this.formatTimeAgo(event.created_at);

      const item = document.createElement('div');
      item.className = 'bookmark-item';
      item.dataset.eventId = event.id;
      item.innerHTML = `
        <div class="bookmark-item__content-wrapper">
          <div class="bookmark-item__author">
            ${this.escapeHtml(username)}
            ${isPrivate ? '<span class="bookmark-item__private-badge">üîí</span>' : ''}
          </div>
          <div class="bookmark-item__content">${this.escapeHtml(snippet)}</div>
          <div class="bookmark-item__timestamp">${timeAgo}</div>
        </div>
        <button class="bookmark-item__delete" aria-label="Remove bookmark" title="Remove bookmark">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 4h10M5 4V3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v1M6 7v4M10 7v4M4 4l.5 8.5a1 1 0 0 0 1 .95h5a1 1 0 0 0 1-.95L12 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      `;

      // Click on content wrapper navigates to note
      const contentWrapper = item.querySelector('.bookmark-item__content-wrapper');
      contentWrapper?.addEventListener('click', () => {
        const router = Router.getInstance();
        const nevent = encodeNevent(event.id);
        router.navigate(`/note/${nevent}`);
      });

      // Click on delete button removes bookmark
      const deleteBtn = item.querySelector('.bookmark-item__delete');
      deleteBtn?.addEventListener('click', async (e) => {
        e.stopPropagation();
        await this.handleDeleteBookmark(event.id, item);
      });

      list.appendChild(item);
    }
    } catch (error) {
      console.error('Failed to render bookmarks:', error);
      container.innerHTML = `
        <div class="bookmarks-empty-state">
          <p>Failed to load bookmarks</p>
        </div>
      `;
    }
  }

  /**
   * Get text snippet (first N chars, strip quotes/reposts)
   */
  private getTextSnippet(content: string, maxLength: number): string {
    // Strip nostr: references and quotes
    let text = content
      .replace(/nostr:(note|nevent|npub|nprofile|naddr|nrelay)[a-zA-Z0-9]+/g, '')
      .replace(/^>.*$/gm, '') // Remove quoted lines
      .trim();

    if (text.length > maxLength) {
      return text.substring(0, maxLength) + '...';
    }
    return text;
  }

  /**
   * Escape HTML to prevent XSS
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Format Unix timestamp to readable date
   */
  private formatTimeAgo(timestamp: number): string {
    const date = new Date(timestamp * 1000);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}`;
  }

  /**
   * Handle delete bookmark
   */
  private async handleDeleteBookmark(eventId: string, itemElement: HTMLElement): Promise<void> {
    const authService = AuthService.getInstance();
    const currentUser = authService.getCurrentUser();
    if (!currentUser) return;

    const bookmarkOrch = BookmarkOrchestrator.getInstance();
    const isPrivate = bookmarkOrch.isPrivateBookmarksEnabled();

    try {
      await bookmarkOrch.removeBookmark(eventId, isPrivate);
      ToastService.show('Bookmark removed', 'success');

      // Remove item from DOM immediately
      itemElement.remove();

      // Emit event to update other components
      const eventBus = EventBus.getInstance();
      eventBus.emit('bookmark:updated', {});
    } catch (error) {
      console.error('Failed to remove bookmark:', error);
      ToastService.show('Failed to remove bookmark', 'error');
    }
  }

  /**
   * Create the main layout structure
   */
  private createElement(): HTMLElement {
    const layout = document.createElement('div');
    layout.className = 'main-layout';
    layout.innerHTML = `
      <aside class="sidebar">
        <div class="sidebar-content">
          <div class="sidebar-header">
            NoorNote
          </div>
          <div class="wallet-balance-container">
            <!-- WalletBalanceDisplay will be mounted here -->
          </div>
          <ul class="primary-nav">
            <li>
              <a href="/" class="home-link" title="Scroll to top">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                  <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
                Timeline
                <svg class="scroll-to-top-btn" viewBox="0 0 176 248" fill="currentColor" style="display: none;" role="button" aria-label="Scroll to top" tabindex="0">
                  <path d="M173.5,117.5 C155.833,118.167 138.167,118.833 120.5,119.5C120.5,146.167 120.5,172.833 120.5,199.5C98.5,199.5 76.5,199.5 54.5,199.5C54.5,172.833 54.5,146.167 54.5,119.5C36.8333,118.833 19.1667,118.167 1.5,117.5C29.9251,78.3137 58.5918,39.3137 87.5,0.5C116.408,39.3137 145.075,78.3137 173.5,117.5 Z"/>
                  <path d="M54.5,211.5 C76.5,211.5 98.5,211.5 120.5,211.5C120.5,215.5 120.5,219.5 120.5,223.5C98.5,223.5 76.5,223.5 54.5,223.5C54.5,219.5 54.5,215.5 54.5,211.5 Z"/>
                  <path d="M120.5,247.5 C98.5,247.5 76.5,247.5 54.5,247.5C54.5,243.5 54.5,239.5 54.5,235.5C76.5,235.5 98.5,235.5 120.5,235.5C120.5,239.5 120.5,243.5 120.5,247.5 Z"/>
                </svg>
              </a>
            </li>
            <li>
              <a href="/profile" class="profile-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                  <circle cx="12" cy="7" r="4"></circle>
                </svg>
                Profile
              </a>
            </li>
            <li>
              <a href="/notifications" class="notifications-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                  <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                </svg>
                Notifications
                <span class="notifications-badge"></span>
              </a>
            </li>
            <li>
              <a href="/messages">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                  <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
                Messages
              </a>
            </li>
            <li>
              <a href="/settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                  <circle cx="12" cy="12" r="3"></circle>
                </svg>
                Settings
              </a>
            </li>
            <li>
              <a href="#" class="search-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                Search
              </a>
            </li>
            <li>
              <a href="#" class="clear-cache-link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                Cache <span class="cache-size-display">--</span>
              </a>
            </li>
          </ul>
          <button class="btn btn--new-post">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"></path>
            </svg>
            New Post
          </button>
          <div class="sidebar-footer">
            <div class="auth-control-container">
              <!-- Login/Logout will be mounted here -->
            </div>
          </div>
        </div>
      </aside>

      <main class="primary-content">
        <!-- Content will be dynamically updated based on auth state -->
      </main>

      <aside class="secondary-content">
        <div class="secondary-user">
          <!-- User status will be mounted here -->
        </div>
        <div class="secondary-tabs">
          <button class="secondary-tab secondary-tab--active" data-tab="system-log">System Logs</button>
          <button class="secondary-tab" data-tab="bookmarks">Bookmarks</button>
        </div>
        <div class="secondary-content-body">
          <div class="secondary-tab-content secondary-tab-content--active" data-tab-content="system-log">
            <!-- Debug Logger will be mounted here -->
          </div>
          <div class="secondary-tab-content" data-tab-content="bookmarks">
            <!-- Bookmarks will be mounted here -->
          </div>
        </div>
      </aside>
    `;

    return layout;
  }

  /**
   * Get the layout element for mounting
   */
  public getElement(): HTMLElement {
    return this.element;
  }

  /**
   * Update sidebar content
   */
  public updateSidebar(content: string): void {
    const sidebar = this.element.querySelector('.sidebar-content');
    if (sidebar) {
      sidebar.innerHTML = content;
    }
  }

  /**
   * Update primary content
   */
  public updatePrimaryContent(content: string): void {
    const primary = this.element.querySelector('.primary-content');
    if (primary) {
      primary.innerHTML = content;
    }
  }

  /**
   * Update secondary content
   */
  public updateSecondaryContent(content: string): void {
    const secondary = this.element.querySelector('.secondary-content');
    if (secondary) {
      secondary.innerHTML = content;
    }
  }

  /**
   * Set user status in secondary header
   */
  public setUserStatus(npub: string, pubkey: string): void {
    // Clean up existing user status
    if (this.userStatus) {
      this.userStatus.destroy();
    }

    // Create new user status with logout callback
    this.userStatus = new UserStatus({
      npub,
      pubkey,
      onLogout: () => this.handleLogout()
    });

    // Mount in secondary user area
    const secondaryUser = this.element.querySelector('.secondary-user');
    if (secondaryUser) {
      secondaryUser.innerHTML = '';
      secondaryUser.appendChild(this.userStatus.getElement());
    }

    // Update profile link href (event listener is set up in setupNavigationLinks)
    const profileLink = this.element.querySelector('.sidebar .profile-link') as HTMLAnchorElement;
    if (profileLink) {
      profileLink.href = `/profile/${npub}`;
    }
  }

  /**
   * Handle logout from UserStatus component
   */
  private handleLogout(): void {
    if (this.authComponent && this.authComponent.handleLogout) {
      // Call AuthComponent's logout method
      this.authComponent.handleLogout();
    }
  }

  /**
   * Clear user status (on logout)
   */
  public clearUserStatus(): void {
    if (this.userStatus) {
      this.userStatus.destroy();
      this.userStatus = null;
    }

    const secondaryUser = this.element.querySelector('.secondary-user');
    if (secondaryUser) {
      secondaryUser.innerHTML = '';
      // Re-mount AuthComponent to show Login button again
      if (this.authComponent) {
        secondaryUser.appendChild(this.authComponent.getElement());
      }
    }

    // Reset profile link on logout (event listener remains in setupNavigationLinks)
    const profileLink = this.element.querySelector('.sidebar .profile-link') as HTMLAnchorElement;
    if (profileLink) {
      profileLink.href = '/profile';
    }
  }

  /**
   * Initialize content areas
   */
  private initializeContent(): void {
    // Mount auth component in secondary-user (top right - Login/Logout)
    this.authComponent = new AuthComponent(this);
    const secondaryUser = this.element.querySelector('.secondary-user');
    if (secondaryUser) {
      secondaryUser.appendChild(this.authComponent.getElement());
    }

    // Mount debug logger in system-log tab content
    const systemLogTab = this.element.querySelector('[data-tab-content="system-log"]');
    if (systemLogTab) {
      systemLogTab.appendChild(this.systemLogger.getElement());
    }

    // Bookmarks tab will be rendered on first click (see setupTabSwitching)

    // Add initial log messages
    this.systemLogger.info('System', 'Noornote application started');
    this.systemLogger.debug('Layout', 'MainLayout initialized with SystemLogger');
  }

  /**
   * Handle clear cache click
   */
  private async handleClearCache(): Promise<void> {
    try {
      // Clear localStorage + sessionStorage
      await this.cacheManager.clearCache({
        localStorage: true,
        sessionStorage: true,
        profileCache: true,
        eventCache: true,
        reload: true
      });
    } catch (error) {
      console.error('Failed to clear cache:', error);
    }
  }

  /**
   * Handle new post button click
   */
  private handleNewPost(): void {
    const postNoteModal = PostNoteModal.getInstance();
    postNoteModal.show();
  }

  /**
   * Start periodic cache size updates
   */
  private startCacheSizeUpdates(): void {
    this.updateCacheSize(); // Initial update
    this.cacheSizeUpdateInterval = window.setInterval(() => {
      this.updateCacheSize();
    }, 5000); // Update every 5 seconds
  }

  /**
   * Update cache size display in sidebar
   */
  private async updateCacheSize(): Promise<void> {
    const cacheSizeDisplay = this.element.querySelector('.cache-size-display');
    if (!cacheSizeDisplay) return;

    const stats = await this.cacheManager.getCacheStats();
    const totalCacheSize = stats.total.size;

    cacheSizeDisplay.textContent = `(${this.cacheManager.formatBytes(totalCacheSize)})`;
  }

  /**
   * Parse byte string (e.g., "2.5 MB", "512 KB") back to bytes
   */
  private parseBytesString(sizeStr: string): number {
    const match = sizeStr.match(/^([\d.]+)\s*([KMGT]?B)$/i);
    if (!match) return 0;

    const value = parseFloat(match[1]);
    const unit = match[2].toUpperCase();

    const multipliers: { [key: string]: number } = {
      'B': 1,
      'KB': 1024,
      'MB': 1024 * 1024,
      'GB': 1024 * 1024 * 1024,
      'TB': 1024 * 1024 * 1024 * 1024
    };

    return Math.floor(value * (multipliers[unit] || 1));
  }

  /**
   * Stop cache size updates
   */
  private stopCacheSizeUpdates(): void {
    if (this.cacheSizeUpdateInterval !== null) {
      clearInterval(this.cacheSizeUpdateInterval);
      this.cacheSizeUpdateInterval = null;
    }
  }

  /**
   * Show login screen (trigger AuthComponent to display login options)
   */
  public showLoginScreen(): void {
    if (this.authComponent && typeof this.authComponent.showLoginScreen === 'function') {
      this.authComponent.showLoginScreen();
    }
  }

  /**
   * Setup notifications badge with real-time updates via EventBus
   */
  private setupNotificationsBadge(): void {
    // Initial update
    this.updateNotificationsBadgeCount();

    // Listen for badge update events via EventBus
    this.badgeUpdateSubscriptionId = this.eventBus.on('notifications:badge-update', () => {
      this.updateNotificationsBadgeCount();
    });
  }

  /**
   * Update notifications badge with unread count
   */
  public updateNotificationsBadgeCount(): void {
    const badge = this.element.querySelector('.notifications-badge') as HTMLElement;
    if (!badge) return;

    // Only show badge if user is logged in
    const currentUser = this.authService.getCurrentUser();
    if (!currentUser) {
      badge.style.display = 'none';
      return;
    }

    // Use NotificationsOrchestrator for badge count (uses fetched notifications + lastSeen)
    const unreadCount = this.notificationsOrch.getUnreadCount();

    if (unreadCount > 0) {
      badge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
      badge.style.display = 'inline-flex';
    } else {
      badge.style.display = 'none';
    }
  }

  /**
   * Update notifications badge (green dot indicator) - DEPRECATED, use updateNotificationsBadgeCount()
   */
  public updateNotificationsBadge(hasUnread: boolean): void {
    const badge = this.element.querySelector('.notifications-badge') as HTMLElement;
    if (!badge) return;

    if (hasUnread) {
      badge.style.display = 'inline-block';
    } else {
      badge.style.display = 'none';
    }
  }

  /**
   * Cleanup resources
   */
  public destroy(): void {
    this.stopCacheSizeUpdates();

    // Unsubscribe from auth state
    if (this.authStateUnsubscribe) {
      this.authStateUnsubscribe();
    }

    // Unsubscribe from badge updates
    if (this.badgeUpdateSubscriptionId) {
      this.eventBus.off(this.badgeUpdateSubscriptionId);
    }

    if (this.userStatus) {
      this.userStatus.destroy();
    }

    if (this.walletBalanceDisplay) {
      this.walletBalanceDisplay.destroy();
    }

    if (this.urlNavigationModal) {
      this.urlNavigationModal.destroy();
    }

    this.element.remove();
  }
}